#
# Config file for Behringer BCR2000 controller
#
@include "devices.cfg"

#
# Example how to configure UI:
#
#ui:
#{
#  master_volume:
#  {
#    ui_object:
#    {
#      type = "setting";
#      position: { x = 1026; y = 0; };
#      size: { w = 300; h = 14; };
#      background = [ 0, 0, 16, 255 ];
#    }
#    text: 
#    {
#      colour = [ 255, 255, 255, 255 ];
#      text = "master volume:";
#      size = 9;
#      offset: { x = 1; y = 3; };
#    }
#    setting:
#    {
#      id = "master-volume";
#      format = "%d";
#    }
#  }
#}
#
# Parser implementation:
#	top level - handles whole "ui" section.
#	  * each entry is a new UI element, ID matching the name.
#	  * ui_object section parsed first - type to create right data structure, common values set
#	  * setting parser - chains to text parser, then parses setting section
#	  * text parser - handles text section, writing data into a common sub-structure
#
# Some thought is needed on how setting changes drive updates to both the UI and
# internal data structures for the synth:
#
# UI:
# * One setting might affect multiple UI elements
# * Multiple settings can affect a single UI element (e.g. envelope)
# * When creating UI element that references a setting, add the UI's ID to a list
#   on the setting that get sent out in event(s) when the setting is changed.
#
# Internal structures:
# * These could be polled from settings at each loop update, in a hard-coded
#   fashion.
# * If internal structures are created & configured dynamically from script, this
#   linkage from setting->structure could become fully data-driven

#
# MIDI controllers - currently these map to hard-coded controllers in the software
#
# A future refinement would be to make these dynamically created, and each one is
# supplied the ID of a setting it controls (these would be hard-coded).
#
controllers:
{
  exit:
  {
    type = "event";
    midi_cc = [ 46 ];
    threshold = 63;
  }
  
  screenshot:
  {
    type = "event";
    midi_cc = [ 45 ];
    threshold = 63;
  }
  
  profile:
  {
    type = "event";
    midi_cc = [ 44 ];
    threshold = 63;
  }
  
  master_volume:
  {
    type = "continuous";
    midi_cc = [ 1, 33 ];
    min = 0;
    max = 4095;
  }
  
  waveform_select:
  {
    type = "continuous";
    midi_cc = [ 2 ];
    min = 0;
    max = 7;
  }
  
  oscilloscope_frequency:
  {
    type = "continuous";
    midi_cc = [ 3 ];
    min = 0;
    max = 127;
  }

  envelope_select:
  {
  	type = "continuous";
    midi_cc = [ 88 ];
    min = 0;
    max = 2;
  }
  
  volume_envelope_attack_time:
  {
    type = "continuous";
    midi_cc = [ 81 ];
    min = 0;
    max = 127;
    selector = "envelope_select";
    selector_value = 0;
  }
  
  volume_envelope_attack_level:
  {
    type = "continuous";
    midi_cc = [ 82 ];
    min = 0;
    max = 127;
  }
  
  volume_envelope_decay_time:
  {
    type = "continuous";
    midi_cc = [ 83 ];
    min = 0;
    max = 127;
  }
  
  volume_envelope_decay_level:
  {
    type = "continuous";
    midi_cc = [ 84 ];
    min = 0;
    max = 127;
  }
  
  volume_envelope_sustain_time:
  {
    type = "continuous_with_held";
    midi_cc = [ 85 ];
    min = 0;
    max = 126;
  }
  
  volume_envelope_release_time:
  {
    type = "continuous";
    midi_cc = [ 86 ];
    min = 0;
    max = 127;
  }
  
  lfo_state:
  {
    type = "continuous";
    midi_cc = [ 89 ];
    min = 0;
    max = 2;
  }
  
  lfo_waveform_select:
  {
    type = "continuous";
    midi_cc = [ 90 ];
    min = 0;
    max = 8;
  }
  
  lfo_frequency:
  {
    type = "continuous";
    midi_cc = [ 91 ];
    min = 0;
    max = 127;
  }
  
  lfo_level:
  {
    type = "continuous";
    midi_cc = [ 92 ];
    min = 0;
    max = 127;
  }
  
  filter_state:
  {
    type = "continuous";
    midi_cc = [ 97 ];
    min = 0;
    max = 2;
  }
  
  filter_frequency:
  {
    type = "continuous";
    midi_cc = [ 0, 32 ];
    min = 0;
    max = 4095;
  }
  
  filter_q:
  {
    type = "continuous";
    midi_cc = [ 9, 41 ];
    min = 0;
    max = 1023;
  }
}

sysex:
{
	init_message = [0x00, 0x20, 0x32, 0x7f, 0x7f, 0x43];
}
